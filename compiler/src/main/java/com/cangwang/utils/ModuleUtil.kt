package com.cangwang.utils

import com.cangwang.bean.ModuleUnitBean
import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonElement
import com.google.gson.JsonObject
import com.google.gson.JsonParser

import java.io.BufferedReader
import java.io.File
import java.io.FileReader
import java.io.FileWriter
import java.io.IOException
import java.io.PrintWriter
import java.util.ArrayList

object ModuleUtil {

    val PROJECT = "ModuleBus"
    val MODULE_UNIT = "ModuleUnit"
    val SEPARATOR = "$$"

    val FACADE_PACKAGE = "com.cangwang.core"
    val MODULE_ANNOTATION = "com.cangwang.annotation"
    val MODULE_MODEL = "com.cangwang.model"
    private val TEMPLATE_PACKAGE = ".template"
    val NAME_OF_MODULEGROUP = PROJECT + SEPARATOR + "Group" + SEPARATOR
    val WARNING_TIPS = "DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY MODULEBUS."


    val IMODULE_GROUP = FACADE_PACKAGE + TEMPLATE_PACKAGE + ".IModuleGroup"
    val IMODULE_UNIT = FACADE_PACKAGE + TEMPLATE_PACKAGE + ".IModuleUnit"
    val IMODULE_PROXY = MODULE_MODEL + ".IModuleProxy"
    val IMODULE_FACTORY = MODULE_MODEL + ".IModuleFactory"
    val METHOD_GET_MODULE = "getModule"
    val METHOD_FACTROY_GET_INSTANCE = "getInstance"
    val METHOD_FACTROY_GET_TEMPLE_LIST = "getTempleList"

    val NAME_OF_MODULEUNIT = MODULE_UNIT + SEPARATOR

    val ANNOTATION_TYPE_MODULEUNIT = MODULE_ANNOTATION + "ModuleUnit"

    val rootPath = System.getProperty("user.dir")
    val ceterFile = "/src/main/assets/center.json"
    val settingFile = System.getProperty("user.dir") + "/settings.gradle"

    var logger: Logger? = null

    var gson = Gson()

    /**
     * 单位缩进字符串。
     */
    private val SPACE = "   "

    fun splitDot(groupName: String): Array<String> {
        return groupName.split("\\.".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()
    }

    fun split(groupName: String): Array<String> {
        return groupName.split(",".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()
    }

    /**
     * 写json文件
     * @param filePath
     * @param sets
     * @throws IOException
     */
    @Throws(IOException::class)
    fun writeJsonFile(filePath: String, sets: String) {
        var sets = sets
        sets = formatJson(sets, true)
        logger!!.info(sets)
        writeFile(filePath, sets)
    }


    @Throws(IOException::class)
    fun writeFile(filePath: String, sets: String) {
        val fw = FileWriter(filePath)
        val out = PrintWriter(fw)
        out.write(sets)
        out.println()
        fw.close()
        out.close()
    }

    fun readJsonFile(path: String): String {
        val file = File(path)
        if (!file.exists()) return ""
        var reader: BufferedReader? = null
        var jsonContent = ""
        try {
            reader = BufferedReader(FileReader(file))
            var tempString: String? = null
            while ((tempString = reader.readLine()) != null) {
                jsonContent += tempString
            }
        } catch (e: Exception) {
            // TODO: handle exception
            e.printStackTrace()
        } finally {
            if (reader != null) {
                try {
                    reader.close()
                } catch (e: IOException) {
                    // TODO Auto-generated catch block
                    e.printStackTrace()
                }

            }
            return jsonContent
        }

    }

    /**
     * 返回格式化JSON字符串。
     *
     * @param json 未格式化的JSON字符串。
     * @return 格式化的JSON字符串。
     */
    fun formatJson(json: String, isSort: Boolean): String {
        val result = StringBuffer()

        val length = json.length
        var number = 0
        var key: Char = 0.toChar()
        //遍历输入字符串。
        for (i in 0 until length) {
            //1、获取当前字符。
            key = json[i]

            //2、如果当前字符是前方括号、前花括号做如下处理：
            if (key == '[' || key == '{') {
                //（1）如果前面还有字符，并且字符为“：”，打印：换行和缩进字符字符串。
                if (i - 1 > 0 && json[i - 1] == ':') {
                    result.append('\n')
                    if (isSort)
                        result.append(indent(number))
                }

                //（2）打印：当前字符。
                result.append(key)

                //（3）前方括号、前花括号，的后面必须换行。打印：换行。
                result.append('\n')

                //（4）每出现一次前方括号、前花括号；缩进次数增加一次。打印：新行缩进。
                number++
                if (isSort)
                    result.append(indent(number))

                //（5）进行下一次循环。
                continue
            }

            //3、如果当前字符是后方括号、后花括号做如下处理：
            if (key == ']' || key == '}') {
                //（1）后方括号、后花括号，的前面必须换行。打印：换行。
                result.append('\n')

                //（2）每出现一次后方括号、后花括号；缩进次数减少一次。打印：缩进。
                number--
                result.append(indent(number))

                //（3）打印：当前字符。
                result.append(key)

                //（4）如果当前字符后面还有字符，并且字符不为“，”，打印：换行。
                if (i + 1 < length && json[i + 1] != ',') {
                    result.append('\n')
                }

                //（5）继续下一次循环。
                continue
            }

            //4、如果当前字符是逗号。逗号后面换行，并缩进，不改变缩进次数。
            if (key == ',') {
                result.append(key)
                result.append('\n')
                if (isSort)
                    result.append(indent(number))
                continue
            }

            //5、打印：当前字符。
            result.append(key)
        }

        return result.toString()
    }

    /**
     * 返回指定次数的缩进字符串。每一次缩进三个空格，即SPACE。
     *
     * @param number 缩进次数。
     * @return 指定缩进次数的字符串。
     */
    private fun indent(number: Int): String {
        val result = StringBuffer()
        for (i in 0 until number) {
            result.append(SPACE)
        }
        return result.toString()
    }

    fun parserJsonArray(strJson: String): JsonArray? {
        //创建一个Gson对象
        //        Gson gson = new Gson();
        //创建一个JsonParser
        val parser = JsonParser()
        //通过JsonParser对象可以把json格式的字符串解析成一个JsonElement对象
        val el = parser.parse(strJson)

        //        //把JsonElement对象转换成JsonObject
        //        JsonObject jsonObj = null;
        //        if(el.isJsonObject()){
        //            jsonObj = el.getAsJsonObject();
        //        }
        //
        //        //把JsonElement对象转换成JsonArray
        //        JsonArray jsonArray = null;
        return if (el.isJsonArray) {
            el.asJsonArray
        } else null

//        //遍历JsonArray对象
        //        Iterator it = jsonArray.iterator();
        //        while(it.hasNext()){
        //            JsonElement e = (JsonElement)it.next();
        //            //JsonElement转换为JavaBean对象
        //            ModuleUnitBean bean= gson.fromJson(e, ModuleUnitBean.class);
        //        }
    }

    @Throws(IOException::class)
    fun createCenterJson(moduleName: String) {
        val directory = System.getProperty("user.dir") + "/" + moduleName + "/src/main/assets"
        val dirFile = File(directory)
        if (!dirFile.exists() && !dirFile.isDirectory) {
            logger!!.info(directory + " is not exists,to create")
            dirFile.mkdir()
        }
        val path = getJsonAddress(moduleName)
        val file = File(path)
        val deleteResult = file.delete()
        val success = file.createNewFile()
        logger!!.info("deleteResult = $deleteResult, path = $path,success = $success")
    }

    @Throws(IOException::class)
    fun readSetting(): List<String>? {
        val file = File(settingFile)
        var reader: BufferedReader? = null
        var settingContent = ""
        try {
            reader = BufferedReader(FileReader(file))
            var tempString: String? = null
            while ((tempString = reader.readLine()) != null) {
                settingContent += tempString
            }
            logger!!.info(settingContent)
            val moduleNameList = ArrayList<String>()
            val moduleList = settingContent.split("':".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()
            for (i in 1 until moduleList.size) {
                moduleNameList.add(moduleList[i].split("'".toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()[0])
            }
            return moduleNameList
        } catch (e: Exception) {
            // TODO: handle exception
            e.printStackTrace()
        }

        return null
    }

    fun listToJson(list: List<ModuleUnitBean>): JsonArray {
        val templetArray = JsonArray()
        for (b in list) {
            templetArray.add(beanToObject(b))
        }
        return templetArray
    }

    fun beanToObject(b: ModuleUnitBean): JsonObject {
        val jsonObject = JsonObject()
        jsonObject.addProperty("path", b.path)
        jsonObject.addProperty("templet", b.templet)
        jsonObject.addProperty("title", b.title)
        jsonObject.addProperty("layoutLevel", b.layoutLevel)
        jsonObject.addProperty("extraLevel", b.extraLevel)
        return jsonObject
    }

    fun getJsonAddress(moduleName: String): String {
        return rootPath + "/" + moduleName + ceterFile
    }
}
